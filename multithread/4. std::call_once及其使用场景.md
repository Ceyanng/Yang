# 单例模式
确保某一个类只能创建一个实例，由于单例实例时全局唯一的，因此在多线程环境种使用单例模式，需要考虑线程安全问题
一般日志系统需要使用单例模式
```c++
//一个简单单例模式的实现
#include<iostream>
#include<thread>
#include<mutex>
class Log {
private:
	Log() {};
public：
	Log(const Log& log) = delete; //禁止移动构造
	Log& operator = (const Log& log) = delete; 

	/* 饿汉版 程序一运行就立刻初始化 ，虽然线程安全，，但是静态对象初始化顺序是未定义的，所以如果在初始化完成之前调用了getInstance方法会返回一个未定义的实例
	static Log& GetInstance() {
		static Log log;
		return log;
	}
	*/
	//懒汉版 需要时才进行初始化，线程不安全
	static Log & GetInstance() {
		static Log* log = nullptr;
		if (!log) log = new Log;
		return *log;
	}
	void PrintLog(std::string msg = "error") {
		std::cout << __TIME__ << ' ' << msg << std::endl;
	}
};

int main() {
	Log::GetInstance().PrintLog("error");
	return 0;
}

```

# 懒汉式线程不安全，需要call_once保证线程安全
线程不安全：
```c++
#include<iostream>
#include<thread>
#include<mutex>
class Log {
private:
	Log() {};
public:
	Log(const Log& log) = delete;
	Log& operator = (const Log& log) = delete;
	static Log & GetInstance() {
		static Log* log = nullptr;
		if (!log) log = new Log;
		return *log;
	}
	void PrintLog(std::string msg = "error") {
		std::cout << __TIME__ << ' ' << msg << std::endl;
	}
};
void print_error() {
	Log::GetInstance().PrintLog();
}

int main() {
	std::thread t1{ print_error };
	std::thread t2{ print_error };
	t1.join();
	t2.join();
	return 0;
}
```
多线程下可能会导致log被初始化两次
解决办法：
```c++

```
